# Сети в Linux



## Part 1. Инструмент ipcalc

- `ipcalc` - это утилита командной строки в Linux, которая используется для вычисления сетевых масок, подсетей, широковещательных адресов и других сетевых характеристик на основе заданного IP-адреса и маски.

**устанавливаем инструмент ipcalc с помощью команды `sudo apt install ipcalc`**

### 1.1. Сети и маски
**1. Адрес сети 192.167.38.54/13**

![ipcalc_1](images/1_1.png)

**2. Перевод маски 255.255.255.0 в префиксную и двоичную запись**

![ipcalc_2](images/1_2.png)

**/15 в обычную и двоичную**

![ipcalc_3](images/1_3.png)

**11111111.11111111.11111111.11110000 в обычную и префиксную**

![ipcalc_4](images/1_4.png)

**3. Минимальный и максимальный хост в сети 12.167.38.4 при масках:**

**/8**

![ipcalc_5](images/1_5.png)

**11111111.11111111.00000000.00000000**

![ipcalc_6](images/1_6.png)

**255.255.254.0**

![ipcalc_7](images/1_7.png)

**/4**

![ipcalc_8](images/1_8.png)

### 1.2. localhost

#### 1) Определить и записать в отчёт, можно ли обратиться к приложению, работающему на localhost, со следующими IP: 194.34.23.100, 127.0.0.2, 127.1.0.1, 128.0.0.1, для этого пропингуем эти адреса с нашей машины.

- можно обратиться
  - 127.0.0.1
  - 127.0.0.2
    
- нельзя обратиться
  - 194.34.23.100
  - 127.1.0.1

### 1.3. Диапазоны и сегменты сетей.

#### 1) Какие из перечисленных IP можно использовать в качестве публичного, а какие только в качестве частных: 10.0.0.45, 134.43.0.2, 192.168.4.2, 172.20.250.4, 172.0.2.1, 192.172.0.1, 172.68.0.2, 172.16.255.255, 10.10.10.10, 192.169.168.1

- Частный и публичный IP-адреса можно определить по их диапазону.

- В IPv4 есть три диапазона частных IP-адресов:

 - 10.0.0.0 - 10.255.255.255 (диапазон /8)
 - 172.16.0.0 - 172.31.255.255 (диапазон /12)
 - 192.168.0.0 - 192.168.255.255 (диапазон /16)
- Все остальные IP-адреса считаются публичными.

- Также утилита ipcalc показывает нам какого типа является адресс.

- частные адресса
  - 10.0.0.45
  - 192.168.4.2
  - 172.20.250.4
  - 172.16.255.255
  - 10.10.10.10

- публичные адресса
  - 134.43.0.2
  - 172.0.2.1
  - 192.172.0.1
  - 172.68.0.2
  - 192.169.168.1

#### 2) Какие из перечисленных IP адресов шлюза возможны у сети 10.10.0.0/18: 10.0.0.1, 10.10.0.2, 10.10.10.10, 10.10.100.1, 10.10.1.255

- диапозон адресов возможны для данной сети - 10.10.0.1 - 10.10.63.254

![ipcalc_9](images/1_9.png)

- Исходя из этого для сети 10.10.0.0 возможны следующие адреса:
  - 10.10.0.2
  - 10.10.10.10
  - 10.10.1.255

## Part 2. Статическая маршрутизация между двумя машинами

#### 2.0.1 Поднять две виртуальные машины (далее -- ws1 и ws2)

![2vm](images/2_1.png)

#### 2.0.2 С помощью команды ip a смотрим существующие сетевые интерфейсы

- машина ws1
![ip_a](images/2_ws1_1.png)

- машина ws2
![ip_a](images/2_ws2_1.png)

#### 2.0.3 Описать сетевой интерфейс, соответствующий внутренней сети, на обеих машинах и задать следующие адреса и маски: ws1 - 192.168.100.10, маска /16, ws2 - 172.24.116.8, маска /12

Сетевой интерфейс, соответствующий внутренней сети, это интерфейс, который подключен к локальной сети внутри организации или домашней сети и предназначен для обмена данными между устройствами в этой сети. Обычно такие интерфейсы имеют адреса из частных IP-диапазонов, например, 192.168.x.x, 172.16.x.x - 172.31.x.x или 10.x.x.x.

В сетевых настройках такой интерфейс может быть настроен для использования DHCP, если адреса присваиваются автоматически, или для использования статических IP-адресов, если адреса присваиваются вручную. Также могут быть настроены другие параметры, такие как маска подсети, шлюз по умолчанию и DNS-серверы.

Кроме того, внутренний интерфейс может иметь дополнительные параметры безопасности, такие как настройки брандмауэра, чтобы защитить локальную сеть от внешних угроз.

- Для открытия файлы конфигурации сетевых интерфейсов используем команду:
`ssudo vim /etc/netplan/00-installer-config.yaml`

- машина ws1
![yaml_1](images/2_ws1_2.png)

- машина ws2
![yaml_2](images/2_ws2_2.png)

#### 2.0.4 Выполнить команду netplan apply для перезапуска сервиса сети

- Прописываю комманды для принятие новых настроек конфигурации сети и перезапуска сервиса:
`sudo netplan apply`

![apply](images/2_3.png)

### 2.1. Добавление статического маршрута вручную

#### 2.1.1 Добавить статический маршрут от одной машины до другой и обратно при помощи команды вида ip r add

- Cтатистически задаю маршрут с помощью команды:
`sudo ip r add <target_network> dev <device>`

- машина ws1
![ip_add_1](images/2_ws1_3.png)

- машина ws2
![ip_add_2](images/2_ws2_3.png)

#### 2.1.2 Пропинговать соединение между машинами

- пропингуем соединения с помощью команды:
`ping -w 3 <target_network>`

- машина ws1
![ping_1](images/2_ws1_5.png)

- машина ws2
![ping_2](images/2_ws2_5.png)

### 2.2.  Добавление статического маршрута с сохранением

- Добавить статический маршрут от одной машины до другой с помощью файла `etc/netplan/00-installer-config.yaml`

- машина ws1
![yaml_3](images/2_ws1_4.png)

- машина ws2
![yaml_4](images/2_ws2_4.png)

#### 2.2.2 Пропинговать соединение между машинами

- пропингуем соединения с помощью команды:
`ping -w 3 <target_network>`

- машина ws1
![ping_1](images/2_ws1_5.png)

- машина ws2
![ping_2](images/2_ws2_5.png)


## Part 3. Утилита iperf3

### 3.1. Скорость соединения

#### Перевести и записать в отчёт: 8 Mbps в MB/s, 100 MB/s в Kbps, 1 Gbps в Mbps

- 8 Mbps == 1 MB/s
- 100 MB/s == 800000 Kbps
- 1 Gbps == 1000 Mbps

### 3.2. Скорость соединения

`Iperf3` - это утилита командной строки для измерения пропускной способности сети TCP и UDP. Она используется для проверки скорости передачи данных между двумя узлами в сети. Одна узел работает в качестве сервера, а другой - в качестве клиента. Клиент отправляет данные на сервер, и утилита измеряет скорость передачи данных, задержку и другие параметры.

Чтобы создать сервер испольузется команда:

> `iperf3 -s [option]`

> `-f` - используется для указания формата отображения результатов измерения скорости сетевого соединения (k - кбит, m - мегабит, g - гигабит или K - килобайт, M - мегабайт, G - гигабайт)

> `-D` - запускает сервер в фоновом режиме, что означает, что сервер будет запущен как демон и не будет выводить результаты тестирования на консоль. Это может быть полезно для длительных тестов или в случае, когда требуется тестировать сеть с использованием многих клиентов.

Чтобы запустить **iperf3** в клиентском режиме используем флаг **-с** и указываем адрес хоста, на котором работает сервер.

> `iperf3 -c [host_address] [oprion]`

#### Измерить скорость соединения между ws1 и ws2

Чтобы измерить скорость передачи данных между двумя ВМ создадим на ws1 сервер, а на ws2 клиента.

Создадим сервер на ws1 командой:

`iperf3 -s`

Создадим клиента на ws2, делающего запрос на созданный ранее сервер:

`iperf3 -c 192.168.100.10`

- машина ws1
![iperf3_1](images/3_ws1.png)

- машина ws2
![iperf3_2](images/3_ws2.png)

Скорость соединения:

- sender: 893 Mbits/sec
- receiver: 893 Mbits/sec

## Part 4. Сетевой экран

Сетевой экран (firewall) - это программное или аппаратное устройство, которое используется для фильтрации трафика в сети, обеспечения безопасности и защиты от вредоносных атак

### 4.1. Утилита iptables

`iptables` - это утилита командной строки для настройки правил фильтрации сетевого трафика в Linux. Она позволяет создавать правила для блокировки или разрешения доступа к определенным портам, протоколам и IP-адресам.

С помощью iptables можно настроить межсетевой экран (firewall), который будет обеспечивать безопасность сетевого трафика, пропуская только тот трафик, который соответствует заранее заданным правилам.

Общий синтаксис команды iptables выглядит так:

`$ iptables [option] [chain] [rule]`

- A - добавить правило в цепочку;
- С - проверить все правила;
- D - удалить правило;
- I - вставить правило с нужным номером;
- L - вывести все правила в текущей цепочке;
- S - вывести все правила;
- F - очистить все правила;
- N - создать цепочку;
- X - удалить цепочку;
- P - установить действие по умолчанию.

Дополнительные опции для правил:

- p - указать протокол, один из tcp, udp, udplite, icmp, icmpv6,esp, ah, sctp,
  m h;
- s - указать ip адрес устройства-отправителя пакета;
- d - указать ip адрес получателя;
- i - входной сетевой интерфейс;
- o - исходящий сетевой интерфейс;
- j - выбрать действие, если правило подошло.

##### Создать файл /etc/firewall.sh, имитирующий фаерволл, на ws1 и ws2:

Переходим в корневую папку и создаем файл firewall.sh на ws1 и ws2:

`sudo touch /etc/firewall.sh`

Чтобы добавить новые правила испльзуем команду:

`sudo vi /etc/firewall.sh`

#### Нужно добавить в файл подряд следующие правила:

1. На ws1 применить стратегию когда в начале пишется запрещающее правило, а в конце пишется разрешающее правило

2. на ws2 применить стратегию когда в начале пишется разрешающее правило, а в конце пишется запрещающее правило (это касается пунктов 4 и 5)

3. открыть на машинах доступ для порта 22 (ssh) и порта 80 (http)

4. запретить echo reply (машина не должна "пинговаться”, т.е. должна быть блокировка на OUTPUT)

5. разрешить echo reply (машина должна "пинговаться")

- машина ws1
![4_1](images/4_ws1_1.png)

- машина ws2
![4_2](images/4_ws2_1.png)

#### Запустить файлы на обеих машинах командами chmod +x /etc/firewall.sh и /etc/firewall.sh

Также пременим команду для просмотра применных правил:

`sudo iptables -L -nv`

- машина ws1
![4_3](images/4_ws1_2.png)

- машина ws2
![4_4](images/4_ws2_2.png)

Первый файл содержит запрещающее правило на выход в начале списка правил, что приводит к тому, что первая машина не может пропинговать другую машину. Второй файл содержит разрешающее правило в начале списка правил, что позволяет второй машине пропинговать другую. Различие между стратегиями в том, что в утилите iptables правила выполняются сверху вниз, то есть если правило запрета находиться выше оно срабатывает, а правило разрешения находящиеся ниже - нет.

### 4.2. Утилита nmap

#### Командой ping найти машину, которая не "пингуется", после чего утилитой nmap показать, что хост машины запущен.

![4_5](images/4_3.png)

**Вижу, что машина ws1 не пингуется, устанавливаю утилиту nmap и проверяю работу ws1.**

![4_6](images/4_4.png)

Как и предполагалось ws1 не може пинговаться ws2 из за настроек таблицы FILTER в цепи INPUT, которые мы сделали в заданиях выше, в то время как ws1 может пинговать ws2.

## Part 5. Статическая маршрутизация сети

![network](images/5.png)

#### Поднять пять виртуальных машин (3 рабочие станции (ws11, ws21, ws22) и 2 роутера (r1, r2))

**Создаем 5 машин и называем их соответсвенно схеме**
![network](images/5_1.png)

### 5.1. Настройка адресов машин

#### Настроить конфигурации машин в etc/netplan/00-installer-config.yaml согласно сети на рисунке.

**Настраиваем статический ip в соответсвии со схемой для каждой машины:**

- машина ws11 и ws 21

![5_1](images/5_11_21_1.png)

- машина ws22

![5_2](images/5_22_1.png)

- машина r1 и r2

![5_3](images/5_r1_r2_1.png)


#### Перезапустить сервис сети. Если ошибок нет, то командой ip -4 a проверить, что адрес машины задан верно. Также пропинговать ws22 с ws21. Аналогично пропинговать r1 с ws11.

Перезапускаем сервисы сети с помощью команды:

`sudo netplan apply`

Проверяем адресса сетевых интерфесов машины командой:

`sudo ip -4 a` > `-4` - вывод только IPv4 адрессов

- машина ws11 и ws 21

![5_4](images/5_11_21_2.png)

- машина ws22

![5_5](images/5_22_2.png)

- машина r1 и r2

![5_6](images/5_r1_r2_2.png)

**Все адресса верны. Теперь пропингуем ws22 с ws21:**

![5_7](images/5_7.png)

**Также пропингуем r1 с ws11:**

![5_8](images/5_8.png)


### 5.2. Включение переадресации IP-адресов.

#### Для включения переадресации IP, выполните команду на роутерах:

 `sysctl -w net.ipv4.ip_forward=1`
 При таком подходе переадресация не будет работать после перезагрузки системы.

Команда sudo sysctl -w net.ipv4.ip_forward=1 включает пересылку пакетов IP на уровне ядра. Это позволяет маршрутизатору пересылать пакеты между разными подсетями в локальной сети.

- `sysctl` используется для настройки параметров ядра операционной системы.

- `-w` указывает на то, что мы хотим изменить значение параметра.

- `net.ipv4.ip_forward` - это имя параметра, который мы хотим изменить. Он отвечает за пересылку пакетов IP на уровне ядра.

- `1` - это значение, которое мы устанавливаем для параметра, чтобы включить пересылку пакетов IP. Значение 0 отключает эту опцию.

![5_9](images/5_9.png)

#### Откройте файл /etc/sysctl.conf и добавьте в него следующую строку:

`net.ipv4.ip_forward = 1`
При использовании этого подхода, IP-переадресация включена на постоянной основе.

- машина r1

![5_10](images/5_10_r1.png)

- машина r2

![5_11](images/5_10_r2.png)


### 5.3. Установка маршрута по-умолчанию

#### Настроить маршрут по-умолчанию (шлюз) для рабочих станций. Для этого добавить default перед IP роутера в файле конфигураций

Настраиваем в конфигурации yaml файла ip роутера наших машин 11 21 22

- машина ws11 и ws 21

![5_12](images/5_11_22_3.png)

- машина ws22

![5_13](images/5_22_3.png)

Применяем изменения в силу:

> `sudo netplan apply`

#### Вызвать ip r и показать, что добавился маршрут в таблицу маршрутизации

Чтобы проверить новый маршрут вызовем таблицу маршрутов командой:

`ip r`

- машина ws11 и ws 21

![5_12](images/5_11_22_4.png)

- машина ws22

![5_13](images/5_22_4.png)

#### Пропинговать с ws11 роутер r2 и показать на r2, что пинг доходит. Для этого использовать команду:

 `tcpdump -tn -i eth1`

Позволяет производить захват сетевого трафика на интерфейсе eth1 в текстовом формате без использования имён хостов и портов. Она предназначена для анализа сетевой активности и может использоваться для отслеживания соединений, поиска узких мест и проблем в сети.

- `-tn`: опция позволяет выводить адреса в числовом формате и пропускать DNS-преобразование имёнхостов;
- `-i` eth1: опция позволяет указать интерфейс, на котором будет производиться захват трафика. Вданном случае захват будет осуществляться на интерфейсе eth1.

Если пропинговать r2 с ws11 то ответ с него не вернется, так как на нем не настроена маршрутизация пакетов. Однако исользуя комадну `tcpdump -tn -i eth1` на r2 мы можем увидеть что все таки сигнал проходит.

Для этого запускаем эту команду на r2 и в этот момент начинаем пинговать с ws11 r2. По итогу на r2 мы увидим что сигнал от ws11 проходит, но не возвращается назад на ws11.

Пингуем с 11 машины на р1.
![5_13](images/5_ws11_5.png)


Видим что сигнал от ws11 проходит.
![5_14](images/5_r2_5.png)


### 5.4. Добавление статических маршрутов

#### Добавить в роутеры r1 и r2 статические маршруты в файле конфигураций. Пример для r1 маршрута в сетку 10.20.0.0/26:

Чтобы роутеры знали, на какой роутер отправлять данные с полученным ip настроим статические маршрут. Для этого требуется внести изменения в yaml файл.

- yaml файлы r1 и r2

![5_15](images/5_r1_r2_yaml.png)

Применим изменения командой:

> `sudo netplan apply`

#### Вызвать ip r и показать таблицы с маршрутами на обоих роутерах. Пример таблицы на r1:

![5_16](images/5_r1_r2_ipr.png)

#### Запустить команды на ws11:

ip r list 10.10.0.0/[маска сети] и ip r list 0.0.0.0/0

![5_17](images/5_ws11_10.png)

Поскольку ws11 находится внутри сети 10.10.0.0/18, то для связи с ней она использует свой собвтенный ip. Однако для чтобы связаться с другими сетями, ws11 использует маршрут по умолчанию и отправляет данные на роутер, чтобы тот доставил их в нужную сеть.

### 5.5. Построение списка маршрутизаторов

Команда `traceroute` отправит серию пакетов с увеличивающимися значениями TTL (Time To Live) и отследит время их прохождения через промежуточные узлы маршрутизации. Это позволяет определить, через какие узлы проходит путь до указанного назначения и сколько времени занимает доставка пакетов до каждого из узлов.

#### Запустить на r1 команду дампа:

`tcpdump -tnv -i eth0`

Команда `tcpdump -tnv -i eth0` запускает утилиту `tcpdump` для захвата сетевого трафика на интерфейсе eth0 в текстовом формате.

`-t` - отключает вывод временной метки

`-n` - отключает вывод имени хоста (или ip-адреса, если опция -n применяется и для анализа IP-адресов)

`-v` - увеличивает уровень детализации вывода

`-i` eth0 - задает интерфейс eth0, на котором будет происходить захват

Запускаем дамп на r1:

![5_17](images/5_r1_dump.png)

#### При помощи утилиты traceroute построить список маршрутизаторов на пути от ws11 до ws21

пингуем с 11 на 21.
![5_18](images/5_ws11_trace.png)

перехватываем трафик на r1.
![5_19](images/5_r1_trace.png)

Traceroute использует принцип увеличения значения поля TTL (Time To Live) в сетевых пакетах для определения маршрута до указанного назначения. Вот основной принцип работы команды traceroute:

- Команда traceroute отправляет серию пакетов с низким значением TTL (обычно 1) к указанномназначению (например, IP-адрес или доменное имя).

- Когда пакет с низким значением TTL попадает на маршрутизатор (или другой узел) по путизначение TTL уменьшается на 1. Если значение TTL достигает нуля, пакет считается истекшим маршрутизатор отправляет обратно сообщение "Time Exceeded" (время истекло) обратно отправителю.

- Команда traceroute записывает адрес каждого промежуточного узла, от которого полученсообщение "Time Exceeded", и время, затраченное на доставку пакета до этого узла.

- Для следующего пакета команда traceroute увеличивает значение TTL на 1 и отправляет его сноваЭто делается для определения следующего узла на маршруте.

- Процесс повторяется, пока пакеты не достигнут указанного назначения или не превысямаксимальное количество прыжков (указанное в команде traceroute).

- В итоге команда traceroute выводит список адресов промежуточных узлов и время задержки ping до каждого узла на пути до указанного назначения.

### Использование протокола ICMP при маршрутизации

`ICMP (Internet Control Message Protocol)` - это протокол, используемый для передачи сообщений об ошибках и управляющих сообщений в сетях IP. ICMP обычно используется для тестирования сети и диагностики соединений. Он работает на уровне интернета (IP) и использует специальные сообщения, называемые ICMP-сообщениями, для передачи информации между устройствами в сети.

#### Запустить на r1 перехват сетевого трафика, проходящего через eth0 с помощью команды:

`sudo tcpdump -n -i eth0 icmp`

![5_20](images/5_r1_trace2.png)

#### Пропинговать с ws11 несуществующий IP (например, 10.30.0.111) с помощью команды:

 `ping -c 1 10.30.0.111`

![5_21](images/5_ws11_trace2.png)

## Part 6. Динамическая настройка IP с помощью DHCP

`DHCP (Dynamic Host Configuration Protocol)` - это протокол сетевого уровня, который позволяет автоматически назначать IP-адреса и другую сетевую конфигурацию устройствам в сети. DHCP позволяет избежать необходимости вручную настраивать каждое устройство в сети и упрощает администрирование сети.

Для использования возможностей DHCP внутри нашей локальной сети, нам необходимо установится `DHCP-сервер` или `dhcpd`.

> `dhcpd` - это программа, которая представляет собой сервер DHCP, используемый для автоматической настройки сетевых параметров устройств, подключенных к сети.

Для его установки используем команду:

> `sudo apt-get install isc-dhcp-server`

`ISC-DHCP (Internet Systems Consortium Dynamic Host Configuration Protocol)` — это реализация DHCP-сервера, разработанная Internet Systems Consortium. DHCP (Dynamic Host Configuration Protocol) - это протокол, используемый для автоматической настройки сетевых настроек компьютеров и других устройств в сети, таких как IP-адреса, маски подсети, шлюзы по умолчанию, DNS-серверы и т.д. Он предоставляет инструменты для настройки и управления DHCP-сервером на Linux-системах.

#### Для r2 настроить в файле /etc/dhcp/dhcpd.conf конфигурацию службы DHCP:

1. указать адрес маршрутизатора по-умолчанию, DNS-сервер и адрес внутренней сети. Пример файла для r2:

Входим в режим редактирования файла `sudo vim /etc/dhcp/dhcpd.conf` и вносим изменения:

![6_1](images/6_1.png)

2. в файле resolv.conf прописать nameserver 8.8.8.8.
`sudo vim /etc/resolv.conf`

![6_2](images/6_2.png)

#### Перезагрузить службу DHCP командой systemctl restart isc-dhcp-server. Машину ws21 перезагрузить при помощи reboot и через ip a показать, что она получила адрес. Также пропинговать ws22 с ws21.

Перезагрузим DHCP комадной:

`sudo systemctl restart isc-dhcp-server`

![6_3](images/6_3.png)

На машинах ws21 и ws22 сделаем DHCP-протокол аткивным и принимаем новые настройски netplan:

![6_4](images/6_4.png)

![6_5](images/6_5.png)

Для перезапуска операционной системы используем на обоих машинах команду:

`sudo systemctl reboot`

Смотрим ip a

- ws21

![6_6](images/6_6.png)

-ws22

![6_7](images/6_7.png)

Пропингуем ws22 с ws21 по выделенному ip:

`ping -c 3 10.20.0.2`

![6_8](images/6_8.png)


#### Указать MAC адрес у ws11, для этого в etc/netplan/00-installer-config.yaml надо добавить строки: macaddress: 10:10:10:10:10:BA, dhcp4: true

Заходим в yaml файл и добавляем туда новый MAC-адрес и активируем DHCP-протокол:

![6_9](images/6_9.png)


#### Для r1 настроить аналогично r2, но сделать выдачу адресов с жесткой привязкой к MAC-адресу (ws11). Провести аналогичные тесты

На r1 нужно также установить dhcpd и отредактировать его с жесткой привязкой к MAC-адресу хоста (ws11). Это значит что конкретный ip внутри одной локальной сети будет всегда принадлежать устройству с конкретны MAC-адресом.

Редактируем файл `sudo vim /etc/dhcp/dhcpd.conf` на r1

![6_10](images/6_10.png)

и в файле resolv.conf прописать nameserver 8.8.8.8.

![6_11](images/6_11.png)


Пропингуем ws11 с ws22 по ее димнамичному адрессу:

![6_12](images/6_12.png)

#### Запросить с ws21 обновление ip адреса

Чтобы запросить обновление ip адреса на для ws21 сперва используем команду для удаления старого адреса:

`sudo dhclient -r`

![6_13](images/6_13.png)

Теперь используем команду для назначения нового адреса:

`sudo dhclient -v`

![6_14](images/6_14.png)

### В отчёте описать, какими опциями DHCP сервера пользовались в данном пункте.

В данному пункте были использованы такие опции DHCP как:

- `option routers` указывает шлюз по умолчанию для клиентов DHCP.
- `option domain-name-servers` определяет DNS-серверы, которые будут использоваться клиентами для разрешения DNS-имен в IP-адреса.
- `option domain-name` задает имя домена по умолчанию, которое будет использоваться клиентами DHCP.


## Part 7. NAT

#### В файле /etc/apache2/ports.conf на ws22 и r1 изменить строку Listen 80 на Listen 0.0.0.0:80, то есть сделать сервер Apache2 общедоступным

`Apache2` - это это свободный веб-сервер, который позволяет создавать и хостить веб-сайты и веб-приложения.

Для начала нам необходимо установить программу apache2 на наши виртуальные машины:

> `sudo apt-get install apache2`

`Listen 80` означает, что сервер будет слушать все доступные IP-адреса на порту 80. Таким образом, сервер будет слушать запросы на порту 80 как с локального хоста, так и с других устройств, если они будут иметь доступ к серверу.

`Listen 0.0.0.0:80` означает тоже самое, но явно указывает, что сервер должен слушать все доступные IP-адреса.

Изменяем этот параметр в файле `/etc/apache2/ports.conf`

- в ws22

![7_1](images/7_1.png)

- в r1

![7_2](images/7_2.png)

#### Запустить веб-сервер Apache командой service apache2 start на ws22 и r1

`service apache2 start`

проверить статус `service apache2 status`

- в ws22

![7_3](images/7_3.png)

- в r1

![7_4](images/7_4.png)


#### Добавить в фаервол, созданный по аналогии с фаерволом из Части 4, на r2 следующие правила:

Создаем файл firewall.sh:

`sudo vi /etc/firewall.sh`

Вносим туда слудующие команды:

1. удаление правил в таблице filter - iptables -F

2. удаление правил в таблице "NAT" - iptables -F -t nat

3. отбрасывать все маршрутизируемые пакеты - iptables --policy FORWARD DROP


![7_5](images/7_5.png)

Даем права этому файлу и запускаем его:

` sudo chmod +x /etc/firewall.sh | bash /etc/firewall.sh`

![7_6](images/7_6.png)


#### Проверить соединение между ws22 и r1 командой ping

<i>При запуске файла с этими правилами, ws22 не должна "пинговаться" с r1</i>

Так как мы запретили форвард пакетов на r2, то r1 не может пинговать ws22:

![7_7](images/7_7.png)


#### Добавить в файл ещё одно правило:

4. разрешить маршрутизацию всех пакетов протокола ICMP

Чтобы разрешить маршрутизацию всех пакетов протокола ICMP с помощью iptables, необходимо выполнить следующую команду:

 `iptables -A FORWARD -p icmp -j ACCEPT`

![7_8](images/7_8.png)

Применяем новые правила и проверяем таблицу правил:

![7_9](images/7_9.png)

#### Проверить соединение между ws22 и r1 командой ping

Теперь пинг проходит

![7_10](images/7_10.png)


#### Добавить в файл ещё два правила:

5. включить SNAT, а именно маскирование всех локальных ip из локальной сети, находящейся за r2 (по обозначениям из Части 5 - сеть 10.20.0.0)

6. включить DNAT на 8080 порт машины r2 и добавить к веб-серверу Apache, запущенному на ws22, доступ извне сети

`SNAT (Source Network Address Translation) и DNAT (Destination Network Address Translation)` - это два типа трансляции IP-адресов, используемых для изменения адресов источника и назначения в IP-пакетах при прохождении через маршрутизатор.

`SNAT` используется для изменения IP-адреса источника, когда пакет покидает локальную сеть и направляется во внешнюю сеть. Это позволяет скрыть реальный IP-адрес отправителя и использовать общедоступный IP-адрес маршрутизатора в качестве источника пакета.

`DNAT` используется для изменения IP-адреса назначения, когда пакет приходит во входящий интерфейс маршрутизатора. Это позволяет перенаправить трафик на другой IP-адрес в локальной сети, скрыть реальный IP-адрес получателя или разрешить доступ к локальным ресурсам из внешней сети.

![7_11](images/7_11.png)

Принимаем новые правила:

`sudo chmid +x /etc/firewall.sh`

`sudo bash /etc/firewall.sh`

#### Проверить соединение по TCP для SNAT, для этого с ws22 подключиться к серверу Apache на r1 командой:

`telnet [адрес] [порт]`

- Telnet - это протокол прикладного уровня, использующийся для удаленного управления устройствами через интернет или локальную сеть. С помощью Telnet можно подключаться к серверам, обычно по протоколу TCP, и взаимодействовать с ними, отправляя команды и получая ответы.

Подключаемся к серверу apache установленному на r1 с ws22:

`telnet 10.100.0.11 80`

![7_12](images/7_12.png)

#### Проверить соединение по TCP для DNAT, для этого с r1 подключиться к серверу Apache на ws22 командой telnet (обращаться по адресу r2 и порту 8080)

Для этого обратимся по ip, который мы перехватили с помощью tcpdump:

`telnet 10.100.0.12 8080`

![7_13](images/7_13.png)


## Part 8. Дополнительно. Знакомство с SSH Tunnels

Запускаем фаерволы из предыдущих заданий:

![8_1](images/8_1.png)

#### Запустить веб-сервер Apache на ws22 только на localhost (то есть в файле /etc/apache2/ports.conf изменить строку Listen 80 на Listen localhost:80)

Изменяем listen  в файле /etc/apache2/ports.conf и запускаем сервер apache:

![8_2](images/8_2.png)

![8_3](images/8_3.png)

#### Воспользоваться Local TCP forwarding с ws21 до ws22, чтобы получить доступ к веб-серверу на ws22 с ws21

`Local TCP forwarding` (также известен как локальное перенаправление портов) - это метод использования SSH для перенаправления трафика между клиентской машиной и сервером SSH. Этот метод позволяет клиентской машине использовать SSH-соединение как "прокси-сервер" для обращения к удаленным ресурсам.`

В нашем случае, мы можем использовать Local TCP forwarding для перенаправления трафика с порта 8080 на ws21 на порт 80 на ws22. Для этого нужно выполнить следующую команду на ws21:

`ssh -L 8080:ws22:80 oceanusp@10.20.0.20`

![8_4](images/8_4.png)


тобы проверить подключение воспользуемся командой на ws22:

`ps aux | grep sshd`

![8_5](images/8_5.png)

#### Воспользоваться Remote TCP forwarding c ws11 до ws22, чтобы получить доступ к веб-серверу на ws22 с ws11

Чтобы это сделать нужно воспользоваться командой `ssh -R`, которая позволяет соедениться со сторонним хостом.

![8_6](images/8_6.png)

Проверим наличие подключения и используем команду `telnet 127.0.0.1 8080`

![8_7](images/8_7.png)

Подключение есть.
